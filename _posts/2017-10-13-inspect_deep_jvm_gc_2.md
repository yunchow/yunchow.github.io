---
layout: post
title: 深入理解 JVM 垃圾回收原理（下）
categories: [技术]
description: 深入理解 JVM 垃圾回收原理（下）
keywords: JVM, GC, Java
---

> 接上篇
>
> 由于文章太长，分两上、下两篇文章来分别说明，这一篇是下篇

## 垃圾回收器

### 串行回收器
如果使用串行回收器，那么年轻代和老年代的垃圾回收都只能使用到一个 CPU 的一个内核去执行，并且是独占的，也就是 **Stop-the-world**，所有的应用线程是挂起状态。

**年轻代使用串行回收器**
下图描述了年轻代的串行回收过程。在 Eden 区的存活对象会被拷贝到一个空的存活区『Survivor』，在这个时候，如果发现较大的对象超过了存活区的空间，那么会直接拷贝到老年代。每一次的对象拷贝的时候，会把对象的年龄『Age』增加一次，当这个对象的年龄超过一定的阀值会被直接拷贝到老年代，否则拷贝进存活区等待下一次的「Copy Collect」。注意这里还有另一个例外的情况，就是如果目标存活区的空间不足以容纳 Eden 区和 From 区的对象时，那么这些对象会直接进入老年代。由此可以看出来年轻代每一块空间大小的设置是需要做针对性优化的。
![serial_ygc.png](/imgs/serial_ygc.png)

当年轻代的回收结束后，Eden 区和其中一个存活区会是空的，而另一个存活区里的对象全是存活的对象。
![ygc_after.png](/imgs/ygc_after.png)

**老年代使用串行回收器**
标记-清理-压缩（mark-sweep-compact）回收算法是老年代和持久代使用的串行回收算法。在标记阶段回收器会对所有存活的对象打上一个标记，然后在清理阶段根据标记去清理掉那些垃圾对象，然后再执行压缩，将所有的仍然存活的对象移动到一个连续的内存空间内，去掉内存中的空间碎片。
![old_ser_gc.png](/imgs/old_ser_gc.png)

**什么时候使用串行回收器**
对于大多数运行在个人客户端上的应用推荐使用串行回收，因为这种情况对低延时没有太大的要求，尤其是当今的硬件水平，对于一个 64Mb 大小的 Heap 空间执行一次 Full GC 可以在半秒内完成。

> 但是对于服务端的互联网应用，对于 JVM 的延时是不可接受的，那么种情况是不推荐使用串行回收的。

**串行回收配置参数**
```
-XX:+UseSerialGC
```
在 JDK5 的非 server 模式下默认开启串行回收。

## 并行回收器
现在很多的 Java 应用运行的机器都会有很大的物理内存和多核 CPU，那么并行回收器（也叫吞吐量回收器）可以最大限度的去使用这些物理资源，从而大大的降低回收延时。

**年轻代使用并行回收器**
对年轻代的串行收集器进行优化后，让其能够使用多核 CPU 的优势执行并行回收。但他依然是一个**停机复制回收器**（stop-the-world and copying collector）。因为他能够使用多 CPU，从而大大降低延时并提高系统吞量。
![par_new_gc.png](/imgs/par_new_gc.png)

**老年代使用并行回收器**
与老年代使用串行回收器的处理过程是相同的，需要标记、清理然后再压缩。

**什么时候使用并行回收器**
在多核 CPU 的机器上，并行回收能大大受益，大大的降低延时同时提高吞吐量。缺点就是老年代的回收代价依然巨大。
> 在大多情况下，优先采用并行回收器而非串行回收

**并行回收器配置参数**
```
-XX:+UseParallelGC
```
在 JDK5 的服务器模式下，默认开始并行回收器。

## 并行压缩回收器
并行压缩回收器是在 JDK5 update 6 这个版本后引入的，他是在并行回收基础上对老年代的回收进行了优化，最终是用来替代并行回收器的。

**年轻代使用并行压缩回收器**
与年轻代使用并行回收情况相同。

**老年代使用并行压缩回收器**
老年代和持久代在收集的时候都是停机状态。回收器会分成三阶段（标记、回收、压缩），每代的内存空间都会被划分若干成固定大小的区域。
首先在标记阶段，基于划分的区域系统会启动基于标记线程，对这些区域进行并行的标记，当发现这些区域中存在至少一个存活对象时，就对这个区域进行登记，记录区域的位置和大小信息。
在回收阶段就是基于标记的区域信息，对区域进行回收。对于这些区域实际上会有一个密度的区别，对于密度小的区域，可以将存活动的对象转移到别的区域，然后再回收掉这个区域，而对于密度大的区域，可以先不管。
在压缩阶段也就是去调整这些区域的密度问题。

**什么时候使用并行压缩回收**
对于多核 CPU 的机器建议使用这种回收器。并且根据 CPU 的内核数量优化并行回收的线程数
```
-XX:ParallelGCThreads=n
```

**配置参数**
```
-XX:+UseParallelOldGC
```

## CMS 回收器




